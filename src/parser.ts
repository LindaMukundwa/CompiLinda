/**
 * Recursive Descent Parser for Alan++
 * Works to validate the tokens generated by the Lexer
 */

import { Token, TokenType, LexerLog } from './main';

// Define AST node interface
export interface ASTNode {
    name: string;
    children: ASTNode[];
    token?: Token;
}

// Define parser result interface
export interface ParserResult {
    ast: ASTNode | null;
    logs: LexerLog[];
    hasErrors: boolean; // Added flag to indicate if there are any errors
}

export class Parser {
    private tokens: Token[];
    private position: number = 0;
    private logs: LexerLog[] = [];
    private errors: number = 0;
    //private warnings: number = 0;
    private programCounter: number = 1;
    private lexerLogs: LexerLog[] = []; // Store lexer logs separately

    constructor(tokens: Token[], lexerLogs: LexerLog[] = []) {
        this.tokens = tokens;
        this.lexerLogs = lexerLogs; // Store the lexer logs
        this.logs = [...lexerLogs]; // Include lexer logs in our logs
        this.addLog('INFO', `PARSER -- Parsing program ${this.programCounter}...`);
    }

    // Get the current token
    private currentToken(): Token {
        return this.tokens[this.position] || { type: TokenType.EOF, value: '', line: 0, column: 0 };
    }

    // Advance to the next token
    private advance(): void {
        this.position++;
    }

    // Updated consume method for better error tracking
    private consume(expectedType: TokenType, errorMessage: string): Token | null {
        const current = this.currentToken();

        if (current.type === expectedType) {
            this.addLog('DEBUG', `PARSER -- Parsing found ${expectedType}`);
            this.advance();
            return current;
        } else {
            this.handleError(`${errorMessage}, got ${current.type} [${current.value}]`, current);
            return null;
        }
    }

    // Maximum iterations guard to prevent infinite loops
    private parseWithMaxIterations<T>(parseFunc: () => T | null, maxIterations: number = 1000): T | null {
        const startPosition = this.position;
        let iterations = 0;

        const result = parseFunc();

        if (this.position === startPosition) {
            iterations++;
            if (iterations >= maxIterations) {
                this.addLog('ERROR', 'PARSER -- Maximum iterations reached, possible infinite loop');
                // Force position advance to get out the loop
                this.advance();
            }
        }

        return result;
    }

    // Check if the current token matches the expected type without consuming it
    private match(type: TokenType): boolean {
        return this.currentToken().type === type;
    }

    // Adding log
    private addLog(level: 'INFO' | 'DEBUG' | 'ERROR' | 'WARNING', message: string): void {
        this.logs.push({
            level,
            message
        });
    }

    // Handling error log
    private handleError(message: string, token: Token): void {
        this.errors++;
        this.addLog('ERROR', `PARSER -- Error:${token.line}:${token.column} ${message}`);
    }

    // Create a new AST node
    private createNode(name: string, token?: Token): ASTNode {
        return {
            name,
            children: [],
            token
        };
    }

    // Add a child node
    private addChild(parent: ASTNode, child: ASTNode): void {
        parent.children.push(child);
    }

    // Finds the end position of the current program
    // updated code to make sure it handles if tokens may be out of order or sync
    private findProgramEnd(startPos: number): number {
        let i = startPos;

        // Skip to the next EOP or EOF
        while (i < this.tokens.length) {
            const token = this.tokens[i];

            if (token.type === TokenType.EOP) {
                return i + 1; // Include the EOP token
            } else if (token.type === TokenType.EOF) {
                return i;
            }

            i++;
        }

        return this.tokens.length;
    }

    // Check if any lexical errors exist for the current program segment
    private hasLexicalErrors(startPos: number, endPos: number): boolean {
        // Get line ranges for the current program
        if (startPos >= this.tokens.length) return false;

        const programStartLine = this.tokens[startPos].line;
        const programEndLine = this.tokens[Math.min(endPos - 1, this.tokens.length - 1)].line;

        // Check if any lexer errors fall within the line range of the current program
        for (const log of this.lexerLogs) {
            if (log.level === 'ERROR') {
                const match = log.message.match(/Error:(\d+):/);
                if (match) {
                    const errorLine = parseInt(match[1], 10);
                    // Check if error is within the current program's line range
                    if (errorLine >= programStartLine && errorLine <= programEndLine) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // Main parse program that allows for multiple programs 
    public parse(): ParserResult {
        // Create a root node to hold all programs
        const rootNode = this.createNode('Programs');
        let hasParsedAnyProgram = false;

        // Parse each program until we reach the end of the token stream
        while (this.position < this.tokens.length && !this.match(TokenType.EOF)) {
            // Store the start position of this program
            const programStart = this.position;

            // Find the end of the current program
            const programEnd = this.findProgramEnd(programStart);

            // Check for lexical errors specifically for this program segment
            if (this.hasLexicalErrors(programStart, programEnd)) {
                this.addLog('WARNING', `PARSER -- Program ${this.programCounter} has lexical errors, skipping parsing`);
                // Skip to the next program
                this.position = programEnd;
                this.programCounter++;
                continue; // Skip this program and move to the next one
            }

            // No lexical errors, attempt parsing
            const errorsBefore = this.errors;
            this.addLog('INFO', `PARSER -- Parsing program ${this.programCounter}...`);
            this.addLog('DEBUG', 'PARSER -- parse()');
            const programNode = this.parseProgram();

            // Check if parsing was successful (no new errors)
            if (programNode && this.errors === errorsBefore) {
                this.addChild(rootNode, programNode);
                hasParsedAnyProgram = true;
                this.addLog('INFO', `PARSER -- Program ${this.programCounter} parsed successfully`);
            } else {
                this.addLog('ERROR', `PARSER -- Program ${this.programCounter} has syntax errors, skipping CST generation`);
                // Error recovery: advance to next program
                this.position = programEnd;
            }

            this.programCounter++;
        }

        // Final reporting
        if (this.errors > 0) {
            this.addLog('ERROR', `PARSER -- Parse completed with ${this.errors} error(s)`);
        } else if (hasParsedAnyProgram) {
            this.addLog('INFO', `PARSER -- Parse completed successfully with ${this.programCounter - 1} program(s) processed`);
        } else {
            this.addLog('WARNING', 'PARSER -- No valid programs found to parse');
        }

        return {
            ast: hasParsedAnyProgram ? rootNode : null,
            logs: this.logs,
            hasErrors: this.errors > 0
        };
    }

    // Skip tokens until we find the start of a new program
    private skipToNextProgram(): void {
        this.addLog('WARNING', `PARSER -- Skipping to next program after error at line ${this.currentToken().line}, column ${this.currentToken().column}`);

        // Keep track of whether we've seen an EOP token
        let foundEOP = false;

        while (this.position < this.tokens.length) {
            // If we find an EOP token, advance past it
            if (this.match(TokenType.EOP)) {
                this.advance();
                foundEOP = true;
                break;
            }
            this.advance();
        }

        if (foundEOP) {
            this.addLog('INFO', 'PARSER -- Found next program start');
        } else {
            this.addLog('WARNING', 'PARSER -- Reached end of input while skipping');
        }
    }

    // Parse program (starting rule) with more loggin
    private parseProgram(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseProgram()');

        const programNode = this.createNode('Program');
        const errorCountBefore = this.errors;

        // Check if we're at the start of a program (should be an open block)
        if (!this.match(TokenType.OPEN_BLOCK)) {
            this.handleError("Expected '{' to start program", this.currentToken());
            return null;
        }

        // Parse block
        //this.addLog('DEBUG', 'PARSER -- Parsing Attempting to parse Block');
        const blockNode = this.parseBlock();
        if (blockNode) {
            this.addChild(programNode, blockNode);
        } else {
            return null;
        }

        // Consume end of program marker
        if (this.match(TokenType.EOP)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Expecting EOP ($)');
            const eop = this.consume(TokenType.EOP, "Expected end of program marker '$'");
            if (eop) {
                this.addLog('DEBUG', 'PARSER -- Parsing Found EOP');
                this.addChild(programNode, this.createNode('EOP', eop));
            } else {
                return null;
            }
        } else {
            this.handleError("Expected end of program marker '$'", this.currentToken());
            return null;
        }

        // Only return the program node if no errors were encountered during parsing
        if (this.errors > errorCountBefore) {
            return null;
        }

        this.addLog('DEBUG', 'PARSER -- Program parsed successfully');
        return programNode;
    }

    // Parse block
    // Add more detailed logs to parseBlock
    private parseBlock(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parsingBlock()');

        const blockNode = this.createNode('Block');

        // Consume left brace
        this.addLog('DEBUG', 'PARSER -- Parsing expecting OPEN_BLOCK ({)');
        const leftBrace = this.consume(TokenType.OPEN_BLOCK, "Expected '{'");
        if (leftBrace) {
            this.addLog('DEBUG', 'PARSER -- Parsing found OPEN_BLOCK');
            this.addChild(blockNode, this.createNode('OpenBlock', leftBrace));
        } else {
            return null;
        }

        // Parse statement list (can be empty)
        //this.addLog('DEBUG', 'PARSER -- Parsing Attempting to parse StatementList');
        const statementListNode = this.parseStatementList();
        if (statementListNode) {
            this.addChild(blockNode, statementListNode);
        }

        // Consume right brace
        this.addLog('DEBUG', 'PARSER -- Parsing expecting CLOSE_BLOCK (})');
        const rightBrace = this.consume(TokenType.CLOSE_BLOCK, "Expected '}'");
        if (rightBrace) {
            this.addLog('DEBUG', 'PARSER -- Parsing found CLOSE_BLOCK');
            this.addChild(blockNode, this.createNode('CloseBlock', rightBrace));
        } else {
            return null;
        }

        this.addLog('DEBUG', 'PARSER -- Parsing Block parsed successfully');
        if (!blockNode.children.some(child => child.name === 'StatementList')) {
            this.addChild(blockNode, this.createNode('StatementList'));
        }
        
        return blockNode;
    }


    // Fix the statement list to prevent infinite loops
    private parseStatementList(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseStatementList()');

        const statementListNode = this.createNode('StatementList');

        // If the next token is a closing brace, this is an empty statement list
        if (this.match(TokenType.CLOSE_BLOCK)) {
            this.addLog('DEBUG', 'PARSER -- Parsing found no valid statement');
            this.addLog('DEBUG', 'PARSER -- Parsing found no more statements (ε production)');
            return statementListNode;
        }

        // Parse statements until we reach a closing brace or end of program
        while (!this.match(TokenType.CLOSE_BLOCK) && !this.match(TokenType.EOP) && !this.match(TokenType.EOF)) {
            //this.addLog('DEBUG', 'PARSER -- Parsing Attempting to parse Statement');
            const positionBefore = this.position;
            const statementNode = this.parseStatement();

            if (statementNode) {
                this.addChild(statementListNode, statementNode);
                this.addLog('DEBUG', 'PARSER -- Parsing Statement parsed successfully');
                this.addLog('DEBUG', 'PARSER -- Parsing StatementList');
            } else {
                // Error recovery: skip to next statement or end of block
                this.addLog('DEBUG', 'PARSER -- Parsing found invalid statement');
                this.skipToNextStatement();
            }

            // Check for infinite loop - if position didn't change, force advance
            if (positionBefore === this.position) {
                this.addLog('ERROR', `PARSER -- Infinite loop detected at token ${this.currentToken().value}, forcing advance`);
                this.advance();
            }
        }

        this.addLog('DEBUG', 'PARSER -- Parsing StatementList parsed successfully');
        return statementListNode;
    }
    // Skip tokens until we find a valid statement start or end of block
    private skipToNextStatement(): void {
        while (!this.match(TokenType.EOP) && !this.match(TokenType.CLOSE_BLOCK)) {
            // Skip to potential statement boundaries
            if (this.match(TokenType.I_TYPE) || this.match(TokenType.S_TYPE) ||
                this.match(TokenType.B_TYPE) || this.match(TokenType.PRINT) ||
                this.match(TokenType.WHILE) || this.match(TokenType.IF) ||
                this.match(TokenType.OPEN_BLOCK)) {
                break;
            }
            this.advance();
        }
    }

    // Parse statement
    // Add more detailed logging to parseStatement
    private parseStatement(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseStatement()');
        const current = this.currentToken();

        //this.addLog('DEBUG', `PARSER -- Parsing Current token: ${current.type} [${current.value}]`);

        if (this.match(TokenType.PRINT)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found PRINT statement');
            return this.parsePrintStatement();
        } else if (this.match(TokenType.I_TYPE) || this.match(TokenType.S_TYPE) || this.match(TokenType.B_TYPE)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found TYPE declaration');
            return this.parseVariableDeclaration();
        } else if (this.match(TokenType.IDENTIFIER)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found IDENTIFIER');
            return this.parseAssignmentStatement();
        } else if (this.match(TokenType.WHILE)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found WHILE statement');
            return this.parseWhileStatement();
        } else if (this.match(TokenType.IF)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found IF statement');
            return this.parseIfStatement();
        } else if (this.match(TokenType.OPEN_BLOCK)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found OPEN_BLOCK');
            return this.parseBlock();
        } else {
            this.handleError(`Unexpected token: ${current.value}`, current);
            this.addLog('DEBUG', 'PARSER -- Parsing found invalid statement');
            return null;
        }
    }

    // Parse print statement with better logging
    private parsePrintStatement(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parsePrintStatement()');
        const printNode = this.createNode('PrintStatement');

        // Consume print keyword
        const printToken = this.consume(TokenType.PRINT, "Expected 'print'");
        if (printToken) {
            this.addChild(printNode, this.createNode('PrintKeyword', printToken));
        } else {
            return null;
        }

        // Consume left parenthesis
        this.addLog('DEBUG', 'PARSER -- Parsing expecting LPAREN');
        const leftParen = this.consume(TokenType.LEFT_PAREN, "Expected '(' after 'print'");
        if (leftParen) {
            this.addLog('DEBUG', 'PARSER -- Parsing found LPAREN');
            this.addChild(printNode, this.createNode('LeftParen', leftParen));
        } else {
            return null;
        }

        // Parse expression
        //this.addLog('DEBUG', 'PARSER -- Parsing Attempting to parse expression');
        if (this.match(TokenType.QUOTE)) {
            const stringNode = this.parseStringExpression();
            if (stringNode) {
                this.addChild(printNode, stringNode);
            } else {
                return null;
            }
        } else {
            const exprNode = this.parseExpression();
            if (exprNode) {
                this.addChild(printNode, exprNode);
            } else {
                return null;
            }
        }

        // Consume right parenthesis
        this.addLog('DEBUG', 'PARSER -- Parsing Expecting RPAREN');
        const rightParen = this.consume(TokenType.RIGHT_PAREN, "Expected ')' to close print statement");
        if (rightParen) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found RPAREN');
            this.addChild(printNode, this.createNode('RightParen', rightParen));
        } else {
            return null;
        }

        this.addLog('DEBUG', 'PARSER -- Parsing PrintStatement parsed successfully');
        return printNode;
    }

    // Parse string expression (for print statements)
    private parseStringExpression(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseStringExpression()');
        const stringNode = this.createNode('StringExpression');

        // Consume opening quote
        const openQuote = this.consume(TokenType.QUOTE, "Expected opening quote");
        if (openQuote) {
            this.addChild(stringNode, this.createNode('Quote', openQuote));
        } else {
            return null;
        }

        // Consume characters
        while (this.match(TokenType.CHAR)) {
            const charToken = this.consume(TokenType.CHAR, "");
            if (charToken) {
                this.addChild(stringNode, this.createNode('Char', charToken));
            }
        }

        // Consume closing quote
        const closeQuote = this.consume(TokenType.QUOTE, "Expected closing quote");
        if (closeQuote) {
            this.addChild(stringNode, this.createNode('Quote', closeQuote));
        } else {
            return null;
        }

        return stringNode;
    }

    // Parse variable declaration
    private parseVariableDeclaration(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseVariableDeclr()');
        const declNode = this.createNode('VariableDeclaration');

        // Parse type
        let typeNode: ASTNode | null = null;

        if (this.match(TokenType.I_TYPE)) {
            const typeToken = this.consume(TokenType.I_TYPE, "");
            if (typeToken) {  // Check if consume returned a token
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('IntType', typeToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.S_TYPE)) {
            const typeToken = this.consume(TokenType.S_TYPE, "");
            if (typeToken) {
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('StringType', typeToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.B_TYPE)) {
            const typeToken = this.consume(TokenType.B_TYPE, "");
            if (typeToken) {
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('BooleanType', typeToken));
            } else {
                return null;
            }
        } else {
            this.handleError("Expected type (int, string, boolean)", this.currentToken());
            return null;
        }

        // If we get here, typeNode should be non-null
        if (typeNode) {
            this.addChild(declNode, typeNode);
        } else {
            return null;
        }

        // Parse identifier
        const identToken = this.consume(TokenType.IDENTIFIER, "Expected identifier");
        if (identToken) {
            const identNode = this.createNode('Identifier', identToken);
            this.addChild(declNode, identNode);
        } else {
            return null;
        }

        return declNode;
    }

    // Parse assignment statement
    private parseAssignmentStatement(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseAssignmentStatement()');
        const assignNode = this.createNode('AssignmentStatement');

        // Parse identifier
        const identToken = this.consume(TokenType.IDENTIFIER, "Expected identifier");
        if (identToken) {
            const identNode = this.createNode('Identifier', identToken);
            this.addChild(assignNode, identNode);
        } else {
            return null;
        }

        // Parse assignment operator
        const assignOp = this.consume(TokenType.ASSIGN, "Expected '=' in assignment");
        if (assignOp) {
            this.addChild(assignNode, this.createNode('AssignOp', assignOp));
        } else {
            return null;
        }

        // Parse expression
        const exprNode = this.parseExpression();
        if (exprNode) {
            this.addChild(assignNode, exprNode);
        } else {
            return null;
        }

        return assignNode;
    }

    // Parse while statement
    private parseWhileStatement(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseWhileStatement()');
        const whileNode = this.createNode('WhileStatement');

        // Consume while keyword
        const whileToken = this.consume(TokenType.WHILE, "Expected 'while'");
        if (whileToken) {
            this.addChild(whileNode, this.createNode('WhileKeyword', whileToken));
        } else {
            return null;
        }

        // Parse boolean expression
        const boolExpr = this.parseBooleanExpression();
        if (boolExpr) {
            this.addChild(whileNode, boolExpr);
        } else {
            return null;
        }

        // Parse block
        const blockNode = this.parseBlock();
        if (blockNode) {
            this.addChild(whileNode, blockNode);
        } else {
            return null;
        }

        return whileNode;
    }

    // Parse if statement
    private parseIfStatement(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseIfStatement()');
        const ifNode = this.createNode('IfStatement');

        // Consume if keyword
        const ifToken = this.consume(TokenType.IF, "Expected 'if'");
        if (ifToken) {
            this.addChild(ifNode, this.createNode('IfKeyword', ifToken));
        } else {
            return null;
        }

        // Parse boolean expression
        const boolExpr = this.parseBooleanExpression();
        if (boolExpr) {
            this.addChild(ifNode, boolExpr);
        } else {
            return null;
        }

        // Parse then block
        const thenBlock = this.parseBlock();
        if (thenBlock) {
            this.addChild(ifNode, thenBlock);
        } else {
            return null;
        }

        // Parse optional else part
        if (this.match(TokenType.ELSE)) {
            const elseToken = this.consume(TokenType.ELSE, "");
            if (elseToken) {
                const elseNode = this.createNode('ElseKeyword', elseToken);
                this.addChild(ifNode, elseNode);

                // Parse else block
                const elseBlock = this.parseBlock();
                if (elseBlock) {
                    this.addChild(ifNode, elseBlock);
                } else {
                    return null;
                }
            } else {
                return null;
            }
        }

        return ifNode;
    }

    // Parse boolean expression
    private parseBooleanExpression(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseBoolean()');
        const boolNode = this.createNode('BooleanExpression');

        // Parse left expression
        const leftExpr = this.parseExpression();
        if (leftExpr) {
            this.addChild(boolNode, leftExpr);
        } else {
            return null;
        }

        // Parse comparison operator
        if (this.match(TokenType.EQUALS)) {
            const eqToken = this.consume(TokenType.EQUALS, "");
            if (eqToken) {
                this.addChild(boolNode, this.createNode('EqualsOp', eqToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.NOT_EQUALS)) {
            const neqToken = this.consume(TokenType.NOT_EQUALS, "");
            if (neqToken) {
                this.addChild(boolNode, this.createNode('NotEqualsOp', neqToken));
            } else {
                return null;
            }
        } else {
            this.handleError("Expected comparison operator (== or !=)", this.currentToken());
            return null;
        }

        // Parse right expression
        const rightExpr = this.parseExpression();
        if (rightExpr) {
            this.addChild(boolNode, rightExpr);
        } else {
            return null;
        }

        return boolNode;
    }

    // Parse expression with more detailed logginf
    private parseExpression(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseExpression()');
        const exprNode = this.createNode('Expression');
        const current = this.currentToken();

        //this.addLog('DEBUG', `PARSER -- Parsing Current token: ${current.type} [${current.value}]`);

        // Special handling for parenthesized expressions or boolean literals
        if (this.match(TokenType.LEFT_PAREN) || this.match(TokenType.BOOLEAN_VALUE)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found LPAREN or BOOLEAN_VAL');
            // Handle specific expression type here...
        } else if (this.match(TokenType.DIGIT)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found DIGIT');
            // Handle integer expression...
        } else if (this.match(TokenType.IDENTIFIER)) {
            this.addLog('DEBUG', 'PARSER -- Parsing Found ID');
            const identToken = this.consume(TokenType.IDENTIFIER, "");
            if (identToken) {
                this.addLog('DEBUG', 'PARSER -- Parsing ID parsed successfully');
                this.addChild(exprNode, this.createNode('Identifier', identToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.QUOTE)) {
            this.addLog('DEBUG', 'PARSER -- Parsing found QUOTE');
            // Handle string expression...
        } else {
            this.handleError(`Expected expression, got ${current.value}`, current);
            return null;
        }

        this.addLog('DEBUG', 'PARSER -- Parsing Expression parsed successfully');
        return exprNode;
    }

    // Parse term
    private parseTerm(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER -- parseTerm()');
        const current = this.currentToken();

        if (this.match(TokenType.DIGIT)) {
            const digitToken = this.consume(TokenType.DIGIT, "");
            if (digitToken) {
                return this.createNode('IntLiteral', digitToken);
            } else {
                return null;
            }
        } else if (this.match(TokenType.IDENTIFIER)) {
            const identToken = this.consume(TokenType.IDENTIFIER, "");
            if (identToken) {
                return this.createNode('Identifier', identToken);
            } else {
                return null;
            }
        } else if (this.match(TokenType.BOOLEAN_VALUE)) {
            const boolToken = this.consume(TokenType.BOOLEAN_VALUE, "");
            if (boolToken) {
                return this.createNode('BooleanLiteral', boolToken);
            } else {
                return null;
            }
        } else {
            this.handleError(`Expected term (digit, identifier, or boolean), got ${current.value}`, current);
            return null;
        }
    }

    // Method to print the CST in a readable format
    public printCST(node: ASTNode | null, indent: string = ''): string {
        if (!node) return 'No parse tree available.';

        let output = '';

        // Special handling for root node
        if (node.name === 'Programs') {
            output += 'Programs Root:\n';
            for (let i = 0; i < node.children.length; i++) {
                output += `Program ${i + 1}:\n`;
                output += this.printCST(node.children[i], indent + '  ');
                if (i < node.children.length - 1) {
                    output += '\n'; // Add separation between programs
                }
            }

            // If there were programs with errors, indicate that
            if (this.programCounter > node.children.length + 1) {
                const skippedCount = this.programCounter - node.children.length - 1;
                output += `\n${skippedCount} program(s) had errors and were not included in the CST.`;
            }

            return output;
        }

        // Regular node handling
        if (node.token) {
            output += `${indent}[${node.token.value}]\n`;
        } else {
            if (node.name !== 'StatementList') {
                output += `${indent}<${node.name}>\n`;
            }
        }

        // Process children
        for (const child of node.children) {
            output += this.printCST(child, indent + '--');
        }

        return output;
    }
}

// Export for browser
declare global {
    interface Window {
        Parser: typeof Parser;
    }
}

(window as any).Parser = Parser;
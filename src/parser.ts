/**
 * Recursive Descent Parser for Alan++
 * Works to validate the tokens generated by the Lexer
 */

import { Token, TokenType, LexerLog } from './main';

// Define AST node interface
export interface ASTNode {
    name: string;
    children: ASTNode[];
    token?: Token;
}

// Define parser result interface
export interface ParserResult {
    ast: ASTNode | null;
    logs: LexerLog[];
}

export class Parser {
    private tokens: Token[];
    private position: number = 0;
    private logs: LexerLog[] = [];
    private errors: number = 0;
    private warnings: number = 0;
    private programCounter: number = 1;

    constructor(tokens: Token[]) {
        this.tokens = tokens;
        this.addLog('INFO', `PARSER: Parsing program ${this.programCounter}...`);
    }

    // Get the current token
    private currentToken(): Token {
        return this.tokens[this.position] || { type: TokenType.EOF, value: '', line: 0, column: 0 };
    }

    // Advance to the next token
    private advance(): void {
        this.position++;
    }

    // Consume the current token if it matches the expected type
    private consume(expectedType: TokenType, errorMessage: string): Token | null {
        const current = this.currentToken();

        if (current.type === expectedType) {
            this.addLog('DEBUG', `PARSER: Consumed ${expectedType} [ ${current.value} ]`);
            this.advance();
            return current;
        } else {
            this.handleError(errorMessage, current);
            return null;
        }
    }

    // Check if the current token matches the expected type without consuming it
    private match(type: TokenType): boolean {
        return this.currentToken().type === type;
    }

    // Add log
    private addLog(level: 'INFO' | 'DEBUG' | 'ERROR' | 'WARNING', message: string): void {
        this.logs.push({
            level,
            message
        });
    }

    // Handle error
    private handleError(message: string, token: Token): void {
        this.errors++;
        this.addLog('ERROR', `PARSER: Error:${token.line}:${token.column} ${message}`);
    }

    // Create a new AST node
    private createNode(name: string, token?: Token): ASTNode {
        return {
            name,
            children: [],
            token
        };
    }

    // Add a child node
    private addChild(parent: ASTNode, child: ASTNode): void {
        parent.children.push(child);
    }

    // Main parse method
    public parse(): ParserResult {
        this.addLog('DEBUG', 'PARSER: parse()');
        const ast = this.parseProgram();

        if (this.errors > 0) {
            this.addLog('ERROR', `PARSER: Parse failed with ${this.errors} error(s)`);
        } else {
            this.addLog('INFO', 'PARSER: Parse completed successfully');
        }

        return {
            ast,
            logs: this.logs
        };
    }

    // Parse program (starting rule)
    private parseProgram(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER: parseProgram()');

        const programNode = this.createNode('Program');

        // Parse block
        const blockNode = this.parseBlock();
        if (blockNode) {
            this.addChild(programNode, blockNode);
        } else {
            return null;
        }

        // Consume end of program marker
        const eop = this.consume(TokenType.EOP, "Expected end of program marker '$'");
        if (eop) {
            this.addChild(programNode, this.createNode('EOP', eop));
        } else {
            return null;
        }

        return programNode;
    }

    // Parse block
    private parseBlock(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER: parseBlock()');

        const blockNode = this.createNode('Block');

        // Consume left brace
        const leftBrace = this.consume(TokenType.OPEN_BLOCK, "Expected '{'");
        if (leftBrace) {
            this.addChild(blockNode, this.createNode('OpenBlock', leftBrace));
        } else {
            return null;
        }

        // Parse statement list
        const statementListNode = this.parseStatementList();
        if (statementListNode) {
            this.addChild(blockNode, statementListNode);
        }

        // Consume right brace
        const rightBrace = this.consume(TokenType.CLOSE_BLOCK, "Expected '}'");
        if (rightBrace) {
            this.addChild(blockNode, this.createNode('CloseBlock', rightBrace));
        } else {
            return null;
        }

        return blockNode;
    }

    // Parse statement list
    private parseStatementList(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER: parseStatementList()');

        const statementListNode = this.createNode('StatementList');

        // If the next token is a closing brace, this is an empty statement list
        if (this.match(TokenType.CLOSE_BLOCK)) {
            return statementListNode;
        }

        // Parse statements until we reach a closing brace
        while (!this.match(TokenType.CLOSE_BLOCK) && !this.match(TokenType.EOP)) {
            const statementNode = this.parseStatement();
            if (statementNode) {
                this.addChild(statementListNode, statementNode);
            } else {
                // Error recovery: skip to next statement or end of block
                this.skipToNextStatement();
            }
        }

        return statementListNode;
    }

    // Skip tokens until we find a valid statement start or end of block
    private skipToNextStatement(): void {
        while (!this.match(TokenType.EOP) && !this.match(TokenType.CLOSE_BLOCK)) {
            // Skip to potential statement boundaries
            if (this.match(TokenType.I_TYPE) || this.match(TokenType.S_TYPE) ||
                this.match(TokenType.B_TYPE) || this.match(TokenType.PRINT) ||
                this.match(TokenType.WHILE) || this.match(TokenType.IF) ||
                this.match(TokenType.OPEN_BLOCK)) {
                break;
            }
            this.advance();
        }
    }

    // Parse statement
    private parseStatement(): ASTNode | null {
        const current = this.currentToken();

        if (this.match(TokenType.PRINT)) {
            return this.parsePrintStatement();
        } else if (this.match(TokenType.I_TYPE) || this.match(TokenType.S_TYPE) || this.match(TokenType.B_TYPE)) {
            return this.parseVariableDeclaration();
        } else if (this.match(TokenType.IDENTIFIER)) {
            return this.parseAssignmentStatement();
        } else if (this.match(TokenType.WHILE)) {
            return this.parseWhileStatement();
        } else if (this.match(TokenType.IF)) {
            return this.parseIfStatement();
        } else if (this.match(TokenType.OPEN_BLOCK)) {
            return this.parseBlock();
        } else {
            this.handleError(`Unexpected token: ${current.value}`, current);
            return null;
        }
    }

    // Parse print statement
    private parsePrintStatement(): ASTNode | null {
        const printNode = this.createNode('PrintStatement');

        // Consume print keyword
        const printToken = this.consume(TokenType.PRINT, "Expected 'print'");
        if (printToken) {
            this.addChild(printNode, this.createNode('PrintKeyword', printToken));
        } else {
            return null;
        }

        // Consume left parenthesis
        const leftParen = this.consume(TokenType.LEFT_PAREN, "Expected '(' after 'print'");
        if (leftParen) {
            this.addChild(printNode, this.createNode('LeftParen', leftParen));
        } else {
            return null;
        }

        // Parse expression
        if (this.match(TokenType.QUOTE)) {
            const stringNode = this.parseStringExpression();
            if (stringNode) {
                this.addChild(printNode, stringNode);
            } else {
                return null;
            }
        } else {
            const exprNode = this.parseExpression();
            if (exprNode) {
                this.addChild(printNode, exprNode);
            } else {
                return null;
            }
        }

        // Consume right parenthesis
        const rightParen = this.consume(TokenType.RIGHT_PAREN, "Expected ')' to close print statement");
        if (rightParen) {
            this.addChild(printNode, this.createNode('RightParen', rightParen));
        } else {
            return null;
        }

        return printNode;
    }

    // Parse string expression (for print statements)
    private parseStringExpression(): ASTNode | null {
        const stringNode = this.createNode('StringExpression');

        // Consume opening quote
        const openQuote = this.consume(TokenType.QUOTE, "Expected opening quote");
        if (openQuote) {
            this.addChild(stringNode, this.createNode('Quote', openQuote));
        } else {
            return null;
        }

        // Consume characters
        while (this.match(TokenType.CHAR)) {
            const charToken = this.consume(TokenType.CHAR, "");
            if (charToken) {
                this.addChild(stringNode, this.createNode('Char', charToken));
            }
        }

        // Consume closing quote
        const closeQuote = this.consume(TokenType.QUOTE, "Expected closing quote");
        if (closeQuote) {
            this.addChild(stringNode, this.createNode('Quote', closeQuote));
        } else {
            return null;
        }

        return stringNode;
    }

    // Parse variable declaration
    private parseVariableDeclaration(): ASTNode | null {
        const declNode = this.createNode('VariableDeclaration');

        // Parse type
        let typeNode: ASTNode | null = null;

        if (this.match(TokenType.I_TYPE)) {
            const typeToken = this.consume(TokenType.I_TYPE, "");
            if (typeToken) {  // Check if consume returned a token
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('IntType', typeToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.S_TYPE)) {
            const typeToken = this.consume(TokenType.S_TYPE, "");
            if (typeToken) {
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('StringType', typeToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.B_TYPE)) {
            const typeToken = this.consume(TokenType.B_TYPE, "");
            if (typeToken) {
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('BooleanType', typeToken));
            } else {
                return null;
            }
        } else {
            this.handleError("Expected type (int, string, boolean)", this.currentToken());
            return null;
        }

        // If we get here, typeNode should be non-null
        if (typeNode) {
            this.addChild(declNode, typeNode);
        } else {
            return null;
        }

        // Parse identifier
        const identToken = this.consume(TokenType.IDENTIFIER, "Expected identifier");
        if (identToken) {
            const identNode = this.createNode('Identifier', identToken);
            this.addChild(declNode, identNode);
        } else {
            return null;
        }

        return declNode;
    }

    // Parse assignment statement
    private parseAssignmentStatement(): ASTNode | null {
        const assignNode = this.createNode('AssignmentStatement');

        // Parse identifier
        const identToken = this.consume(TokenType.IDENTIFIER, "Expected identifier");
        if (identToken) {
            const identNode = this.createNode('Identifier', identToken);
            this.addChild(assignNode, identNode);
        } else {
            return null;
        }

        // Parse assignment operator
        const assignOp = this.consume(TokenType.ASSIGN, "Expected '=' in assignment");
        if (assignOp) {
            this.addChild(assignNode, this.createNode('AssignOp', assignOp));
        } else {
            return null;
        }

        // Parse expression
        const exprNode = this.parseExpression();
        if (exprNode) {
            this.addChild(assignNode, exprNode);
        } else {
            return null;
        }

        return assignNode;
    }

    // Parse while statement
    private parseWhileStatement(): ASTNode | null {
        const whileNode = this.createNode('WhileStatement');

        // Consume while keyword
        const whileToken = this.consume(TokenType.WHILE, "Expected 'while'");
        if (whileToken) {
            this.addChild(whileNode, this.createNode('WhileKeyword', whileToken));
        } else {
            return null;
        }

        // Parse boolean expression
        const boolExpr = this.parseBooleanExpression();
        if (boolExpr) {
            this.addChild(whileNode, boolExpr);
        } else {
            return null;
        }

        // Parse block
        const blockNode = this.parseBlock();
        if (blockNode) {
            this.addChild(whileNode, blockNode);
        } else {
            return null;
        }

        return whileNode;
    }

    // Parse if statement
    private parseIfStatement(): ASTNode | null {
        const ifNode = this.createNode('IfStatement');

        // Consume if keyword
        const ifToken = this.consume(TokenType.IF, "Expected 'if'");
        if (ifToken) {
            this.addChild(ifNode, this.createNode('IfKeyword', ifToken));
        } else {
            return null;
        }

        // Parse boolean expression
        const boolExpr = this.parseBooleanExpression();
        if (boolExpr) {
            this.addChild(ifNode, boolExpr);
        } else {
            return null;
        }

        // Parse then block
        const thenBlock = this.parseBlock();
        if (thenBlock) {
            this.addChild(ifNode, thenBlock);
        } else {
            return null;
        }

        // Parse optional else part
        if (this.match(TokenType.ELSE)) {


            const elseToken = this.consume(TokenType.ELSE, "");
            if (elseToken) {
                const elseNode = this.createNode('ElseKeyword', elseToken);
                this.addChild(ifNode, elseNode);

                // Parse else block
                const elseBlock = this.parseBlock();
                if (elseBlock) {
                    this.addChild(ifNode, elseBlock);
                } else {
                    return null;
                }
            } else {
                return null;
            }
        }

        return ifNode;
    }

    // Parse boolean expression
    private parseBooleanExpression(): ASTNode | null {
        const boolNode = this.createNode('BooleanExpression');

        // Parse left expression
        const leftExpr = this.parseExpression();
        if (leftExpr) {
            this.addChild(boolNode, leftExpr);
        } else {
            return null;
        }

        // Parse comparison operator
        if (this.match(TokenType.EQUALS)) {
            const eqToken = this.consume(TokenType.EQUALS, "");
            if (eqToken) {
                this.addChild(boolNode, this.createNode('EqualsOp', eqToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.NOT_EQUALS)) {
            const neqToken = this.consume(TokenType.NOT_EQUALS, "");
            if (neqToken) {
                this.addChild(boolNode, this.createNode('NotEqualsOp', neqToken));
            } else {
                return null;
            }
        } else {
            this.handleError("Expected comparison operator (== or !=)", this.currentToken());
            return null;
        }

        // Parse right expression
        const rightExpr = this.parseExpression();
        if (rightExpr) {
            this.addChild(boolNode, rightExpr);
        } else {
            return null;
        }

        return boolNode;
    }

    // Parse expression
    private parseExpression(): ASTNode | null {
        const exprNode = this.createNode('Expression');

        // Parse term
        const termNode = this.parseTerm();
        if (termNode) {
            this.addChild(exprNode, termNode);
        } else {
            return null;
        }

        // Check for int operation
        if (this.match(TokenType.INT_OP)) {
            const opToken = this.consume(TokenType.INT_OP, "");
            if (opToken) {
                this.addChild(exprNode, this.createNode('IntOp', opToken));

                // Parse right term
                const rightTerm = this.parseTerm();
                if (rightTerm) {
                    this.addChild(exprNode, rightTerm);
                } else {
                    return null;
                }
            } else {
                return null;
            }
        }

        return exprNode;
    }

    // Parse term
    private parseTerm(): ASTNode | null {
        const current = this.currentToken();

        if (this.match(TokenType.DIGIT)) {
            const digitToken = this.consume(TokenType.DIGIT, "");
            if (digitToken) {
                return this.createNode('IntLiteral', digitToken);
            } else {
                return null;
            }
        } else if (this.match(TokenType.IDENTIFIER)) {
            const identToken = this.consume(TokenType.IDENTIFIER, "");
            if (identToken) {
                return this.createNode('Identifier', identToken);
            } else {
                return null;
            }
        } else if (this.match(TokenType.BOOLEAN_VALUE)) {
            const boolToken = this.consume(TokenType.BOOLEAN_VALUE, "");
            if (boolToken) {
                return this.createNode('BooleanLiteral', boolToken);
            } else {
                return null;
            }
        } else {
            this.handleError(`Expected term (digit, identifier, or boolean), got ${current.value}`, current);
            return null;
        }
    }

    // Method to print the CST in a readable format
    public printCST(node: ASTNode | null, indent: string = ''): string {
        if (!node) return 'No parse tree available.';

        let output = '';

        // Add node information
        if (node.token) {
            output += `${indent}[${node.token.value}]\n`;
        } else {
            if (node.name !== 'Program' && node.name !== 'StatementList') {
                output += `${indent}[${node.name}]\n`;
            }
        }

        // Process children
        for (const child of node.children) {
            output += this.printCST(child, indent + '--');
        }

        return output;
    }
}

// Export for browser
declare global {
    interface Window {
        Parser: typeof Parser;
    }
}

(window as any).Parser = Parser;
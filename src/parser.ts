/**
 * Recursive Descent Parser for Alan++
 * Works to validate the tokens generated by the Lexer
 */

import { Token, TokenType, LexerLog } from './main';

// Define AST node interface
export interface ASTNode {
    name: string;
    children: ASTNode[];
    token?: Token;
}

// Define parser result interface
export interface ParserResult {
    ast: ASTNode | null;
    logs: LexerLog[];
}

export class Parser {
    private tokens: Token[];
    private position: number = 0;
    private logs: LexerLog[] = [];
    private errors: number = 0;
    //private warnings: number = 0;
    private programCounter: number = 1;

    constructor(tokens: Token[]) {
        this.tokens = tokens;
        this.addLog('INFO', `PARSER: Parsing program ${this.programCounter}...`);
    }

    // Get the current token
    private currentToken(): Token {
        return this.tokens[this.position] || { type: TokenType.EOF, value: '', line: 0, column: 0 };
    }

    // Advance to the next token
    private advance(): void {
        this.position++;
    }

    // Consume the current token if it matches the expected type
    private consume(expectedType: TokenType, errorMessage: string): Token | null {
        const current = this.currentToken();

        if (current.type === expectedType) {
            // this.addLog('DEBUG', `PARSER: Consumed ${expectedType} [ ${current.value} ]`);
            this.advance();
            return current;
        } else {
            this.handleError(errorMessage, current);
            return null;
        }
    }

    // Check if the current token matches the expected type without consuming it
    private match(type: TokenType): boolean {
        return this.currentToken().type === type;
    }

    // Add log
    private addLog(level: 'INFO' | 'DEBUG' | 'ERROR' | 'WARNING', message: string): void {
        this.logs.push({
            level,
            message
        });
    }

    // Handle error
    private handleError(message: string, token: Token): void {
        this.errors++;
        this.addLog('ERROR', `PARSER: Error:${token.line}:${token.column} ${message}`);
    }

    // Create a new AST node
    private createNode(name: string, token?: Token): ASTNode {
        return {
            name,
            children: [],
            token
        };
    }

    // Add a child node
    private addChild(parent: ASTNode, child: ASTNode): void {
        parent.children.push(child);
    }

    // Finds the end position of the current program
    private findProgramEnd(startPos: number): number {
        let depth = 0;
        let i = startPos;

        // Skip to the next EOP or EOF
        while (i < this.tokens.length) {
            const token = this.tokens[i];

            if (token.type === TokenType.OPEN_BLOCK) {
                depth++;
            } else if (token.type === TokenType.CLOSE_BLOCK) {
                depth--;
            } else if (token.type === TokenType.EOP) {
                return i + 1; // Include the EOP token
            } else if (token.type === TokenType.EOF) {
                return i;
            }

            i++;
        }

        return this.tokens.length;
    }

    // updated function to check for errors within each singular program and stopping parsing
    // instead of skipping entire parse by checking logs array for ERROR
    private hasLexicalErrors(startPos: number, endPos: number, logs: LexerLog[]): boolean {
        // Check if any ERROR logs fall within the range of the current program
        for (const log of logs) {
            if (log.level === 'ERROR') {
                // Extract line and column from the log message
                const match = log.message.match(/Error:(\d+):(\d+)/);
                if (match) {
                    const errorLine = parseInt(match[1], 10);
                    const errorColumn = parseInt(match[2], 10);
    
                    // Check if the error is within the current program's token range
                    for (let i = startPos; i < endPos; i++) {
                        if (i < this.tokens.length && this.tokens[i].line === errorLine && this.tokens[i].column === errorColumn) {
                            return true; // Lexical error found in this program
                        }
                    }
                }
            }
        }
        return false; // No lexical errors found in this program
    }

    // Main parse program that allows for multiple programs 
    // Modified parse method that works with your token types
    // updated parse function to skip programs with lex errors from logs array
    public parse(): ParserResult {
        // Debug log
        console.log("Initial tokens:", this.tokens.map(t => `${t.type}:${t.value}`).join(', '));
    
        // Create a root node to hold all programs
        const rootNode = this.createNode('Programs');
        let hasParsedAnyProgram = false;
    
        // Parse each program until we reach the end of the token stream
        while (this.position < this.tokens.length && !this.match(TokenType.EOF)) {
            // Find the end of the current program
            const programStart = this.position;
            const programEnd = this.findProgramEnd(programStart);
    
            this.addLog('INFO', `PARSER: Processing program ${this.programCounter} from position ${programStart} to ${programEnd}`);
    
            // Check for lexical errors in the current program range
            if (this.hasLexicalErrors(programStart, programEnd, this.logs)) {
                this.addLog('WARNING', `PARSER: Program ${this.programCounter} has lexical errors, skipping`);
                // Skip to the next program
                this.position = programEnd;
                this.programCounter++;
                continue; // Skip this program and move to the next one
            }
    
            // No lexical errors, attempt parsing
            this.addLog('INFO', `PARSER: Parsing program ${this.programCounter}...`);
            const programNode = this.parseProgram();
    
            if (programNode) {
                this.addChild(rootNode, programNode);
                hasParsedAnyProgram = true;
                this.addLog('INFO', `PARSER: Program ${this.programCounter} parsed successfully`);
            } else {
                this.addLog('ERROR', `PARSER: Program ${this.programCounter} has syntax errors`);
                // Error recovery: skip to next program
                this.position = programEnd;
            }
    
            this.programCounter++;
        }
    
        if (this.errors > 0) {
            this.addLog('ERROR', `PARSER: Parse completed with ${this.errors} error(s)`);
        } else if (hasParsedAnyProgram) {
            this.addLog('INFO', `PARSER: Parse completed successfully with ${this.programCounter - 1} program(s) processed`);
        } else {
            this.addLog('WARNING', 'PARSER: No valid programs found to parse');
        }
    
        // Return the root node if we parsed at least one program, otherwise null
        return {
            ast: hasParsedAnyProgram ? rootNode : null,
            logs: this.logs
        };
    }


    // Skip tokens until we find the start of a new program
    private skipToNextProgram(): void {
        this.addLog('WARNING', `PARSER: Skipping to next program after error at line ${this.currentToken().line}, column ${this.currentToken().column}`);

        // Keep track of whether we've seen an EOP token
        let foundEOP = false;

        while (this.position < this.tokens.length) {
            // If we find an EOP token, advance past it
            if (this.match(TokenType.EOP)) {
                this.advance();
                foundEOP = true;
                break;
            }
            this.advance();
        }

        if (foundEOP) {
            this.addLog('INFO', 'PARSER: Found next program start');
        } else {
            this.addLog('WARNING', 'PARSER: Reached end of input while skipping');
        }
    }


    // Parse program (starting rule)
    private parseProgram(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER: parseProgram()');

        const programNode = this.createNode('Program');

        // Check if we're at the start of a program (should be an open block)
        if (!this.match(TokenType.OPEN_BLOCK)) {
            this.handleError("Expected '{' to start program", this.currentToken());
            return null;
        }

        // Parse block
        const blockNode = this.parseBlock();
        if (blockNode) {
            this.addChild(programNode, blockNode);
        } else {
            return null;
        }

        // Consume end of program marker
        const eop = this.consume(TokenType.EOP, "Expected end of program marker '$'");
        if (eop) {
            this.addChild(programNode, this.createNode('EOP', eop));
        } else {
            return null;
        }

        return programNode;
    }

    // Parse block
    private parseBlock(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER: parseBlock()');

        const blockNode = this.createNode('Block');

        // Consume left brace
        const leftBrace = this.consume(TokenType.OPEN_BLOCK, "Expected '{'");
        if (leftBrace) {
            this.addChild(blockNode, this.createNode('OpenBlock', leftBrace));
        } else {
            return null;
        }

        // Parse statement list
        const statementListNode = this.parseStatementList();
        if (statementListNode) {
            this.addChild(blockNode, statementListNode);
        }

        // Consume right brace
        const rightBrace = this.consume(TokenType.CLOSE_BLOCK, "Expected '}'");
        if (rightBrace) {
            this.addChild(blockNode, this.createNode('CloseBlock', rightBrace));
        } else {
            return null;
        }

        return blockNode;
    }

    // Parse statement list
    private parseStatementList(): ASTNode | null {
        this.addLog('DEBUG', 'PARSER: parseStatementList()');

        const statementListNode = this.createNode('StatementList');

        // If the next token is a closing brace, this is an empty statement list
        if (this.match(TokenType.CLOSE_BLOCK)) {
            return statementListNode;
        }

        // Parse statements until we reach a closing brace
        while (!this.match(TokenType.CLOSE_BLOCK) && !this.match(TokenType.EOP)) {
            const statementNode = this.parseStatement();
            if (statementNode) {
                this.addChild(statementListNode, statementNode);
            } else {
                // Error recovery: skip to next statement or end of block
                this.skipToNextStatement();
            }
        }

        return statementListNode;
    }

    // Skip tokens until we find a valid statement start or end of block
    private skipToNextStatement(): void {
        while (!this.match(TokenType.EOP) && !this.match(TokenType.CLOSE_BLOCK)) {
            // Skip to potential statement boundaries
            if (this.match(TokenType.I_TYPE) || this.match(TokenType.S_TYPE) ||
                this.match(TokenType.B_TYPE) || this.match(TokenType.PRINT) ||
                this.match(TokenType.WHILE) || this.match(TokenType.IF) ||
                this.match(TokenType.OPEN_BLOCK)) {
                break;
            }
            this.advance();
        }
    }

    // Parse statement
    private parseStatement(): ASTNode | null {
        const current = this.currentToken();

        if (this.match(TokenType.PRINT)) {
            return this.parsePrintStatement();
        } else if (this.match(TokenType.I_TYPE) || this.match(TokenType.S_TYPE) || this.match(TokenType.B_TYPE)) {
            return this.parseVariableDeclaration();
        } else if (this.match(TokenType.IDENTIFIER)) {
            return this.parseAssignmentStatement();
        } else if (this.match(TokenType.WHILE)) {
            return this.parseWhileStatement();
        } else if (this.match(TokenType.IF)) {
            return this.parseIfStatement();
        } else if (this.match(TokenType.OPEN_BLOCK)) {
            return this.parseBlock();
        } else {
            this.handleError(`Unexpected token: ${current.value}`, current);
            return null;
        }
    }

    // Parse print statement
    private parsePrintStatement(): ASTNode | null {
        const printNode = this.createNode('PrintStatement');

        // Consume print keyword
        const printToken = this.consume(TokenType.PRINT, "Expected 'print'");
        if (printToken) {
            this.addChild(printNode, this.createNode('PrintKeyword', printToken));
        } else {
            return null;
        }

        // Consume left parenthesis
        const leftParen = this.consume(TokenType.LEFT_PAREN, "Expected '(' after 'print'");
        if (leftParen) {
            this.addChild(printNode, this.createNode('LeftParen', leftParen));
        } else {
            return null;
        }

        // Parse expression
        if (this.match(TokenType.QUOTE)) {
            const stringNode = this.parseStringExpression();
            if (stringNode) {
                this.addChild(printNode, stringNode);
            } else {
                return null;
            }
        } else {
            const exprNode = this.parseExpression();
            if (exprNode) {
                this.addChild(printNode, exprNode);
            } else {
                return null;
            }
        }

        // Consume right parenthesis
        const rightParen = this.consume(TokenType.RIGHT_PAREN, "Expected ')' to close print statement");
        if (rightParen) {
            this.addChild(printNode, this.createNode('RightParen', rightParen));
        } else {
            return null;
        }

        return printNode;
    }

    // Parse string expression (for print statements)
    private parseStringExpression(): ASTNode | null {
        const stringNode = this.createNode('StringExpression');

        // Consume opening quote
        const openQuote = this.consume(TokenType.QUOTE, "Expected opening quote");
        if (openQuote) {
            this.addChild(stringNode, this.createNode('Quote', openQuote));
        } else {
            return null;
        }

        // Consume characters
        while (this.match(TokenType.CHAR)) {
            const charToken = this.consume(TokenType.CHAR, "");
            if (charToken) {
                this.addChild(stringNode, this.createNode('Char', charToken));
            }
        }

        // Consume closing quote
        const closeQuote = this.consume(TokenType.QUOTE, "Expected closing quote");
        if (closeQuote) {
            this.addChild(stringNode, this.createNode('Quote', closeQuote));
        } else {
            return null;
        }

        return stringNode;
    }

    // Parse variable declaration
    private parseVariableDeclaration(): ASTNode | null {
        const declNode = this.createNode('VariableDeclaration');

        // Parse type
        let typeNode: ASTNode | null = null;

        if (this.match(TokenType.I_TYPE)) {
            const typeToken = this.consume(TokenType.I_TYPE, "");
            if (typeToken) {  // Check if consume returned a token
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('IntType', typeToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.S_TYPE)) {
            const typeToken = this.consume(TokenType.S_TYPE, "");
            if (typeToken) {
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('StringType', typeToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.B_TYPE)) {
            const typeToken = this.consume(TokenType.B_TYPE, "");
            if (typeToken) {
                typeNode = this.createNode('Type', typeToken);
                this.addChild(typeNode, this.createNode('BooleanType', typeToken));
            } else {
                return null;
            }
        } else {
            this.handleError("Expected type (int, string, boolean)", this.currentToken());
            return null;
        }

        // If we get here, typeNode should be non-null
        if (typeNode) {
            this.addChild(declNode, typeNode);
        } else {
            return null;
        }

        // Parse identifier
        const identToken = this.consume(TokenType.IDENTIFIER, "Expected identifier");
        if (identToken) {
            const identNode = this.createNode('Identifier', identToken);
            this.addChild(declNode, identNode);
        } else {
            return null;
        }

        return declNode;
    }

    // Parse assignment statement
    private parseAssignmentStatement(): ASTNode | null {
        const assignNode = this.createNode('AssignmentStatement');

        // Parse identifier
        const identToken = this.consume(TokenType.IDENTIFIER, "Expected identifier");
        if (identToken) {
            const identNode = this.createNode('Identifier', identToken);
            this.addChild(assignNode, identNode);
        } else {
            return null;
        }

        // Parse assignment operator
        const assignOp = this.consume(TokenType.ASSIGN, "Expected '=' in assignment");
        if (assignOp) {
            this.addChild(assignNode, this.createNode('AssignOp', assignOp));
        } else {
            return null;
        }

        // Parse expression
        const exprNode = this.parseExpression();
        if (exprNode) {
            this.addChild(assignNode, exprNode);
        } else {
            return null;
        }

        return assignNode;
    }

    // Parse while statement
    private parseWhileStatement(): ASTNode | null {
        const whileNode = this.createNode('WhileStatement');

        // Consume while keyword
        const whileToken = this.consume(TokenType.WHILE, "Expected 'while'");
        if (whileToken) {
            this.addChild(whileNode, this.createNode('WhileKeyword', whileToken));
        } else {
            return null;
        }

        // Parse boolean expression
        const boolExpr = this.parseBooleanExpression();
        if (boolExpr) {
            this.addChild(whileNode, boolExpr);
        } else {
            return null;
        }

        // Parse block
        const blockNode = this.parseBlock();
        if (blockNode) {
            this.addChild(whileNode, blockNode);
        } else {
            return null;
        }

        return whileNode;
    }

    // Parse if statement
    private parseIfStatement(): ASTNode | null {
        const ifNode = this.createNode('IfStatement');

        // Consume if keyword
        const ifToken = this.consume(TokenType.IF, "Expected 'if'");
        if (ifToken) {
            this.addChild(ifNode, this.createNode('IfKeyword', ifToken));
        } else {
            return null;
        }

        // Parse boolean expression
        const boolExpr = this.parseBooleanExpression();
        if (boolExpr) {
            this.addChild(ifNode, boolExpr);
        } else {
            return null;
        }

        // Parse then block
        const thenBlock = this.parseBlock();
        if (thenBlock) {
            this.addChild(ifNode, thenBlock);
        } else {
            return null;
        }

        // Parse optional else part
        if (this.match(TokenType.ELSE)) {


            const elseToken = this.consume(TokenType.ELSE, "");
            if (elseToken) {
                const elseNode = this.createNode('ElseKeyword', elseToken);
                this.addChild(ifNode, elseNode);

                // Parse else block
                const elseBlock = this.parseBlock();
                if (elseBlock) {
                    this.addChild(ifNode, elseBlock);
                } else {
                    return null;
                }
            } else {
                return null;
            }
        }

        return ifNode;
    }

    // Parse boolean expression
    private parseBooleanExpression(): ASTNode | null {
        const boolNode = this.createNode('BooleanExpression');

        // Parse left expression
        const leftExpr = this.parseExpression();
        if (leftExpr) {
            this.addChild(boolNode, leftExpr);
        } else {
            return null;
        }

        // Parse comparison operator
        if (this.match(TokenType.EQUALS)) {
            const eqToken = this.consume(TokenType.EQUALS, "");
            if (eqToken) {
                this.addChild(boolNode, this.createNode('EqualsOp', eqToken));
            } else {
                return null;
            }
        } else if (this.match(TokenType.NOT_EQUALS)) {
            const neqToken = this.consume(TokenType.NOT_EQUALS, "");
            if (neqToken) {
                this.addChild(boolNode, this.createNode('NotEqualsOp', neqToken));
            } else {
                return null;
            }
        } else {
            this.handleError("Expected comparison operator (== or !=)", this.currentToken());
            return null;
        }

        // Parse right expression
        const rightExpr = this.parseExpression();
        if (rightExpr) {
            this.addChild(boolNode, rightExpr);
        } else {
            return null;
        }

        return boolNode;
    }

    // Parse expression
    private parseExpression(): ASTNode | null {
        const exprNode = this.createNode('Expression');

        // Parse term
        const termNode = this.parseTerm();
        if (termNode) {
            this.addChild(exprNode, termNode);
        } else {
            return null;
        }

        // Check for int operation
        if (this.match(TokenType.INT_OP)) {
            const opToken = this.consume(TokenType.INT_OP, "");
            if (opToken) {
                this.addChild(exprNode, this.createNode('IntOp', opToken));

                // Parse right term
                const rightTerm = this.parseTerm();
                if (rightTerm) {
                    this.addChild(exprNode, rightTerm);
                } else {
                    return null;
                }
            } else {
                return null;
            }
        }

        return exprNode;
    }

    // Parse term
    private parseTerm(): ASTNode | null {
        const current = this.currentToken();

        if (this.match(TokenType.DIGIT)) {
            const digitToken = this.consume(TokenType.DIGIT, "");
            if (digitToken) {
                return this.createNode('IntLiteral', digitToken);
            } else {
                return null;
            }
        } else if (this.match(TokenType.IDENTIFIER)) {
            const identToken = this.consume(TokenType.IDENTIFIER, "");
            if (identToken) {
                return this.createNode('Identifier', identToken);
            } else {
                return null;
            }
        } else if (this.match(TokenType.BOOLEAN_VALUE)) {
            const boolToken = this.consume(TokenType.BOOLEAN_VALUE, "");
            if (boolToken) {
                return this.createNode('BooleanLiteral', boolToken);
            } else {
                return null;
            }
        } else {
            this.handleError(`Expected term (digit, identifier, or boolean), got ${current.value}`, current);
            return null;
        }
    }

    // Method to print the CST in a readable format as well as document any errors while parsing
    public printCST(node: ASTNode | null, indent: string = ''): string {
        if (!node) return 'No parse tree available.';

        let output = '';

        // Special handling for root node
        if (node.name === 'Programs') {
            output += 'Programs Root:\n';
            for (let i = 0; i < node.children.length; i++) {
                output += `Program ${i + 1}:\n`;
                output += this.printCST(node.children[i], indent + '  ');
                if (i < node.children.length - 1) {
                    output += '\n'; // Add separation between programs
                }
            }

            // If there were programs with errors, indicate that
            if (this.programCounter > node.children.length + 1) {
                const skippedCount = this.programCounter - node.children.length - 1;
                output += `\n${skippedCount} program(s) had errors and were not included in the CST.`;
            }

            return output;
        }

        // Regular node handling
        if (node.token) {
            output += `${indent}[${node.token.value}]\n`;
        } else {
            if (node.name !== 'StatementList') {
                output += `${indent}[${node.name}]\n`;
            }
        }

        // Process children
        for (const child of node.children) {
            output += this.printCST(child, indent + '--');
        }

        return output;
    }
}

// Export for browser
declare global {
    interface Window {
        Parser: typeof Parser;
    }
}

(window as any).Parser = Parser;